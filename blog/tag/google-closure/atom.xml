<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Google Closure | Programming Design Notes]]></title>
  <link href="http://pro.ctlok.com/blog/tag/google-closure/atom.xml" rel="self"/>
  <link href="http://pro.ctlok.com/"/>
  <updated>2012-03-30T16:04:35+08:00</updated>
  <id>http://pro.ctlok.com/</id>
  <author>
    <name><![CDATA[Lawrence Cheung]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用 Google Closure Compiler 在執行期間壓縮 Javascript]]></title>
    <link href="http://pro.ctlok.com/2011/10/closure-compiler-run-time-compress.html"/>
    <updated>2011-10-21T14:16:00+08:00</updated>
    <id>http://pro.ctlok.com/2011/10/closure-compiler-run-time-compress</id>
    <content type="html"><![CDATA[<p>趁有空又寫寫文章，今次介紹的是 <b>Google Closure Compiler</b>，其實之前已經介紹過一次: <a href="http://pro.ctlok.com/2010/01/javascript_22.html">線上 <b>Javascript</b> 工具</a>，這個工具可以將 <b>Javascript</b> 的大小大幅降低。<br /><br />使用線上工具去壓縮有一個缺點就是要將 <b>Javascript</b> 檔案儲存成 <b>2</b> 份，1 份是原始檔案，另 1 份是經壓縮內容的 <b>Javascript</b>，因為不可能更改經壓縮過的內容，每一次更改檔案就需要更改原始檔案，然後利用 <b>Google Closure Compiler</b> 線上工具再壓縮一次，再更新壓縮內容，而且經壓縮的 <b>Javascript</b> 在瀏覽器 <b>debug</b> 亦比較困難。雖然你可以在 <b>HTML</b> 將引入的 <b>Javascript</b> 檔案改為未經壓縮然後 <b>debug</b>，但萬一忘記改回就麻煩了。<br /><br />幸好 <b>Google Closure Compiler</b> 有提供到 <b>Java</b> 使用的 <b>API</b> 來達到執行期間 <b>(Run Time)</b> 將 <b>Javascript</b> 壓縮。<br /><br />首先到 <b>Google Code</b> 下載: <a href="http://code.google.com/p/closure-compiler/downloads/list">Google Closure Compiler</a><br /><br />可用以下其中一個方法去壓縮:<br /><pre class="brush: java">protected String compress(InputStream inputStream) throws IOException{<br />    Compiler compiler = new Compiler();<br />    <br />    CompilerOptions options = new CompilerOptions();<br />    CompilationLevel.SIMPLE_OPTIMIZATIONS<br />            .setOptionsForCompilationLevel(options);<br />    <br />    JSSourceFile extern = JSSourceFile.fromCode(&quot;externs.js&quot;, &quot; &quot;);<br />    JSSourceFile input = JSSourceFile.fromInputStream(&quot;origin.js&quot;, inputStream);<br />    compiler.compile(extern, input, options);<br />    <br />    return compiler.toSource();<br />}<br /><br />protected String compress(String str) throws IOException{<br />    Compiler compiler = new Compiler();<br />    <br />    CompilerOptions options = new CompilerOptions();<br />    CompilationLevel.SIMPLE_OPTIMIZATIONS<br />            .setOptionsForCompilationLevel(options);<br />    <br />    JSSourceFile extern = JSSourceFile.fromCode(&quot;externs.js&quot;, &quot; &quot;);<br />    JSSourceFile input = JSSourceFile.fromCode(&quot;origin.js&quot;, str);<br />    compiler.compile(extern, input, options);<br />    <br />    return compiler.toSource();<br />}<br /></pre><br />其中 CompilationLevel 分別有 3 個選項:<br /><ul><li>CompilationLevel.WHITESPACE_ONLY</li><li>CompilationLevel.SIMPLE_OPTIMIZATIONS</li><li>CompilationLevel.ADVANCED_OPTIMIZATIONS</li></ul><br /><b>WHITESPACE_ONLY</b> 只會移除 <b>Javascript</b> 的空白。<br /><br /><b>SIMPLE_OPTIMIZATIONS</b> 是最常用的一種，移除 <b>Javascript</b> 的空白，而且將一些 <b>Local Variable</b> 或 <b>Local Function</b> 名稱改變，並將一些沒有用到的 <b>Variable</b> 移除，大幅提高 <b>Javascript</b> 的壓縮率。<br /><br /><b>ADVANCED_OPTIMIZATIONS</b> 是最高壓縮率的模式，將所有 <b>Variable</b> 或 <b>Function</b> 的名稱改變，有使用 <b>Javascript Framework</b> 不建議使用這個選項。<br /><br />在真實環境中我們可以加入一個 <b>Filter</b> 去將 <b>Javascript</b> 壓縮:<br /><pre class="brush: js">package com.ctlok.pro.filter;<br /><br />import java.io.IOException;<br />import java.io.InputStream;<br />import java.util.HashMap;<br />import java.util.Map;<br />import java.util.logging.Level;<br /><br />import javax.servlet.Filter;<br />import javax.servlet.FilterChain;<br />import javax.servlet.FilterConfig;<br />import javax.servlet.ServletException;<br />import javax.servlet.ServletRequest;<br />import javax.servlet.ServletResponse;<br />import javax.servlet.http.HttpServletRequest;<br />import javax.servlet.http.HttpServletResponse;<br /><br />import com.google.javascript.jscomp.CompilationLevel;<br />import com.google.javascript.jscomp.Compiler;<br />import com.google.javascript.jscomp.CompilerOptions;<br />import com.google.javascript.jscomp.JSSourceFile;<br />import com.google.javascript.jscomp.WarningLevel;<br /><br />public class ClosureCompilerFilter implements Filter {<br /><br />    //for cache<br />    private final Map&lt;String, String&gt; compressedJs = new HashMap&lt;String, String&gt;();<br />    private FilterConfig filterConfig;<br />    <br />    public void init(FilterConfig filterConfig) throws ServletException {<br />        this.filterConfig = filterConfig;<br />        <br />        //Turn off the compiler log<br />        Compiler.setLoggingLevel(Level.OFF);<br />    }<br /><br />    public void destroy() {<br /><br />    }<br /><br />    public void doFilter(ServletRequest request, ServletResponse response,<br />            FilterChain chain) throws IOException, ServletException {<br />        <br />        HttpServletRequest req = (HttpServletRequest) request;<br />        HttpServletResponse resp = (HttpServletResponse) response;<br />        <br />        String uri = req.getRequestURI();<br />        <br />        //Prevent compress the compressed Javascript, such as jquery.min.js, mootools.min.js, etc.<br />        if (!uri.matches(&quot;.<em>\.min\.js$&quot;)){<br />            String js = null;<br />            <br />            if (compressedJs.containsKey(uri)){<br />                //get from cache<br />                js = compressedJs.get(uri);<br />            }else{<br />                String contextPath = req.getContextPath();<br />                String jsPath = uri.substring(contextPath.length());<br />                <br />                //get javascript file as stream<br />                //getResourceAsStream cannot include context path<br />                InputStream inputStream = filterConfig.getServletContext().getResourceAsStream(jsPath);<br />                js = compress(inputStream);<br />                <br />                //put to cache<br />                compressedJs.put(uri, js);<br />            }<br />            <br />            resp.getWriter().write(js);<br />            return;<br />        }<br />        <br />        chain.doFilter(request, response);<br />    }<br />    <br />    protected String compress(InputStream inputStream) throws IOException{<br />        Compiler compiler = new Compiler();<br />        <br />        CompilerOptions options = new CompilerOptions();<br />        CompilationLevel.SIMPLE_OPTIMIZATIONS<br />                .setOptionsForCompilationLevel(options);<br />        WarningLevel.QUIET.setOptionsForWarningLevel(options);<br />        <br />        JSSourceFile extern = JSSourceFile.fromCode(&quot;externs.js&quot;, &quot;&quot;);<br />        JSSourceFile input = JSSourceFile.fromInputStream(&quot;origin.js&quot;, inputStream);<br />        compiler.compile(extern, input, options);<br /><br />        return compiler.toSource();<br />    }<br /><br />}<br /></pre><br />在 web.xml 加上:<br /><pre class="brush: xml">&lt;filter&gt;<br />    &lt;display-name&gt;ClosureCompilerFilter&lt;/display-name&gt;<br />    &lt;filter-name&gt;ClosureCompilerFilter&lt;/filter-name&gt;<br />    &lt;filter-class&gt;com.ctlok.pro.filter.ClosureCompilerFilter&lt;/filter-class&gt;<br />&lt;/filter&gt;<br />&lt;filter-mapping&gt;<br />    &lt;filter-name&gt;ClosureCompilerFilter&lt;/filter-name&gt;<br />    &lt;url-pattern&gt;</em>.js&lt;/url-pattern&gt;<br />&lt;/filter-mapping&gt;<br /></pre><br />這樣就可以令到 <b>.js</b> 結尾的 <b>Javascript</b> 檔案經壓縮再傳出去，又不會將 <b>.min.js</b> 已經壓縮過的 <b>Javascript</b> 又再壓縮一次。<br />經過壓縮後會儲存在 <b>Map</b> 內，畢竟壓縮的時間也不短。<br /><br />例如我有一個 /js/myjs.js 的檔案:<br /><pre class="brush: js">function ctlok() {<br />    var self = this;<br />    var $ = jQuery;<br /><br />     this.publicFunction = function() {<br />           localFunction();<br />      };<br /><br />     var localFunction = function() {<br />          var aaaaa = &#39;aaaaa&#39;;<br />          $(&#39;:input&#39;).val(aaaaa);<br />     };<br />}<br /></pre><br />經壓縮後變成:<br /><pre class="brush: js">function ctlok(){var a=jQuery;this.publicFunction=function(){a(&quot;:input&quot;).val(&quot;aaaaa&quot;)}};<br /></pre><br />範例下載:: <a href="https://sites.google.com/site/lawrencespace/lawpronotes/download/Google-Closure-Compiler.zip">Google-Closure-Compiler.zip</a><div class="blogger-post-footer"><img width='1' height='1' src='https://blogger.googleusercontent.com/tracker/5998578522192555089-3261921414800777822?l=lawpronotes.blogspot.com' alt='' /></div></p>
]]></content>
  </entry>
  
</feed>
